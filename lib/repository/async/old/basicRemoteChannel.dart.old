import 'dart:async';
import 'dart:convert';

import 'package:dart_amqp/dart_amqp.dart';
import 'package:techviz/repository/session.dart';

class BasicRemoteChannel<T>  {
  Future<T> publishMessage(dynamic object, String routingKeyName, {String exchangeName = "techViz", String queueName, String replyRoutingKeyName, Function parser, bool durable = false, bool autoDelete = false}) {

    final Completer<T> _completer = Completer();

    Session().rabbitmqClient.then((Client client){

      client.errorListener((dynamic error){
        _completer.completeError(error);
      });

      return client.channel();
    }).then((Channel channel){
      return channel.exchange(exchangeName, ExchangeType.TOPIC, durable: true );
    }).then((Exchange exchange){
      MessageProperties props = MessageProperties();
      props.persistent = true;
      props.contentType = 'application/json';

      bool listenForResponse = queueName!= null && parser!=null;


      if(!listenForResponse) {
        exchange.publish(JsonEncoder().convert(object), routingKeyName, properties: props);
        _completer.complete();
      }




      exchange.channel.queue(queueName, autoDelete: autoDelete, durable: durable,).then((Queue queue){
          return queue.bind(exchange, routingKeyName);
      }).then((Queue queue){
        return queue.consume();
      }).then((Consumer consumer){

        consumer.listen((AmqpMessage message) {
          if(message.routingKey == replyRoutingKeyName){
            Map<String, dynamic> jsonResult = message.payloadAsJson as Map<String, dynamic>;
            return consumer.cancel().then((Consumer consumer){
              return _completer.complete(parser(jsonResult) as T);
            });
          }
        }).onError((dynamic error){
          _completer.completeError(error);
        });

        exchange.publish(JsonEncoder().convert(object), routingKeyName, properties: props);
      });

    });

    return _completer.future;
  }

  void publishSimpleMessage(dynamic object, String routingKeyName, String exchangeName) {

    Session().rabbitmqClient.then((Client client){
      return client.channel();
    }).then((Channel channel){
      return channel.exchange(exchangeName, ExchangeType.TOPIC, durable: true );
    }).then((Exchange exchange){
      MessageProperties props = MessageProperties();
      props.persistent = true;
      props.contentType = 'application/json';

      exchange.publish(JsonEncoder().convert(object), routingKeyName, properties: props);
    });
  }
}